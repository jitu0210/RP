import Event from "../models/eventsModel.js";

// Helper to format datetime into separate date & time
const formatDateTime = (date) => {
  const d = new Date(date);
  const formattedDate = d.toLocaleDateString("en-GB"); // DD/MM/YYYY
  const formattedTime = d.toLocaleTimeString("en-GB"); // HH:MM:SS
  return { date: formattedDate, time: formattedTime };
};

// In-memory live events (latest values)
let liveEvents = [];

// Simulate polling relay every 100ms
setInterval(() => {
  const signals = ["BreakerStatus", "Overcurrent", "Undervoltage", "RelayTrip"];
  liveEvents = signals.map(sig => {
    const { date, time } = formatDateTime(new Date());
    return {
      date,
      time,
      signalName: sig,
      value: Math.round(Math.random()) // random 0 or 1 for demo
    };
  });
}, 100);

// Auto-generate error events every 10s
setInterval(async () => {
  const errorSignals = ["RelayFault", "CommunicationError", "HardwareFailure"];
  const randomError = errorSignals[Math.floor(Math.random() * errorSignals.length)];

  const errorEvent = new Event({
    signalName: randomError,
    value: 1,
    errorType: "AutoGeneratedError"
  });

  await errorEvent.save();
  console.log("Error saved:", randomError);
}, 10000);

// Controller to fetch all events
export const getLiveEvents = async (req, res) => {
  try {
    // Get last 10 error events from DB
    const errorEventsRaw = await Event.find({ errorType: { $ne: null } })
      .sort({ datetime: -1 })
      .limit(10);

    // Format datetime for error events
    const errorEvents = errorEventsRaw.map(ev => {
      const { date, time } = formatDateTime(ev.datetime);
      return {
        date,
        time,
        signalName: ev.signalName,
        value: ev.value,
        errorType: ev.errorType
      };
    });

    res.json({
      live: liveEvents,
      errors: errorEvents
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
};
